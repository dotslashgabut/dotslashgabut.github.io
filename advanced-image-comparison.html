<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Image Comparison App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 30px;
            text-align: center;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            padding: 30px;
            border-bottom: 1px solid #eee;
        }
        
        .file-inputs {
            display: grid;
            /* Changed to 2 columns to accommodate both file and URL inputs */
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .file-input-group {
            position: relative;
            /* Added flex to align label and input/button vertically */
            display: flex;
            flex-direction: column;
            align-items: stretch; /* Stretch items to fill the group */
        }
        
        .file-input-label {
            display: block;
            padding: 20px;
            border: 3px dashed #4facfe;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%);
            flex-grow: 1; /* Allow label to grow and fill space */
            display: flex; /* For vertical centering of content */
            flex-direction: column;
            justify-content: center;
        }
        
        .file-input-label:hover {
            border-color: #00f2fe;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
        }
        
        /* ONLY hide the file input type, not text inputs */
        input[type="file"].file-input {
            display: none;
        }
        
        /* Styles for the new URL text input fields */
        .file-input-group input[type="text"] {
            width: 100%;
            padding: 10px;
            margin-top: 10px; /* Space between label and input */
            border: 1px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
            display: block; /* Ensure it's visible and takes up space */
            font-size: 1rem; /* Adjust font size for better readability */
        }
        
        /* Styles for the new "Load URL" buttons */
        .btn-url {
            margin-top: 10px; /* Space between input and button */
            width: 100%;
            display: block; /* Make the button take full width */
            text-align: center;
        }
        
        .toolbar {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #333;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .comparison-container {
            position: relative;
            width: auto;
            height: 600px;
            margin: 30px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            cursor: grab;
        }
        
        .comparison-container:active {
            cursor: grabbing;
        }
        
        .image-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.1s ease;
            user-select: none;
            -webkit-user-drag: none;
        }
        
        .image-before {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            clip-path: polygon(0 0, 50% 0, 50% 100%, 0 100%);
        }
        
        .slider {
            position: absolute;
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            /* background: white; */
            /* background: linear-gradient(180deg, #4facfe 0%, #00f2fe 100%); */
            cursor: ew-resize;
            z-index: 10;
            transform: translateX(-50%);
            /* box-shadow: 0 0 20px rgba(79, 172, 254, 0.8); */
            pointer-events: auto; /* Ensure slider can capture events */
        }
        
        .slider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            /* width: 30px;
            height: 30px;
            background: white;
            border: 2px solid #4facfe;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); */
            pointer-events: auto; /* Ensure handle can capture events */
        }
        
        .slider::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* color: #4facfe;
            font-size: 16px;
            font-weight: bold; */
            pointer-events: none;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }
        
        .zoom-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .zoom-btn:hover {
            background: white;
            transform: scale(1.1);
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 20;
            font-family: monospace;
            min-width: 200px;
            /* backdrop-filter: blur(10px); */
        }
        
        .fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1000;
            background: black;
        }
        
        .fullscreen .comparison-container {
            width: 100vw;
            height: 100vh;
            margin: 0;
            border-radius: 0;
        }
        
        .exit-fullscreen {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 30;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            /* backdrop-filter: blur(10px); */
        }
        
        .preset-images {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .preset-btn {
            padding: 8px 16px;
            border: 2px solid #4facfe;
            border-radius: 20px;
            background: transparent;
            color: #4facfe;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .preset-btn:hover {
            background: #4facfe;
            color: white;
        }
        
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4facfe;
            font-size: 18px;
            z-index: 15;
        }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(79, 172, 254, 0.3);
            border-radius: 50%;
            border-top-color: #4facfe;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .file-inputs {
                /* Changed to 1 column for better mobile layout */
                grid-template-columns: 1fr;
            }
            
            .toolbar {
                justify-content: center;
            }
            
            .btn {
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .comparison-container {
                height: 400px;
                margin: 15px;
            }
            
            .info-panel {
                font-size: 12px;
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>✨ Advanced Image Comparison</h1>
            <p>Compare images with precision and style</p>
        </div>
        
        <div class="controls">
            <div class="file-inputs">
                <div class="file-input-group">
                    <label for="image1" class="file-input-label">
                        <div>📷 Choose Image 1 (Before)</div>
                        <small>Click or drag to upload</small>
                    </label>
                    <input type="file" id="image1" class="file-input" accept="image/*">
                </div>
                <div class="file-input-group">
                    <label for="image2" class="file-input-label">
                        <div>📷 Choose Image 2 (After)</div>
                        <small>Click or drag to upload</small>
                    </label>
                    <input type="file" id="image2" class="file-input" accept="image/*">
                </div>
            
                <div class="file-input-group">
                    <label for="imageUrl1" class="file-input-label">
                        <div>🔗 Image 1 URL (Before)</div>
                        <small>Paste image URL here</small>
                    </label>
                    <input type="text" id="imageUrl1" class="file-input" placeholder="e.g., https://example.com/image-before.jpg">
                    <button class="btn btn-primary btn-url" onclick="comparison.loadImageFromUrl(document.getElementById('imageUrl1').value, 'before')">Load URL</button>
                </div>
                <div class="file-input-group">
                    <label for="imageUrl2" class="file-input-label">
                        <div>🔗 Image 2 URL (After)</div>
                        <small>Paste image URL here</small>
                    </label>
                    <input type="text" id="imageUrl2" class="file-input" placeholder="e.g., https://example.com/image-after.jpg">
                    <button class="btn btn-primary btn-url" onclick="comparison.loadImageFromUrl(document.getElementById('imageUrl2').value, 'after')">Load URL</button>
                </div>
            </div>
            
            <div class="toolbar">
                <button class="btn btn-primary" onclick="toggleFullscreen()">🔍 Fullscreen</button>
                <button class="btn btn-secondary" onclick="resetZoom()">🔄 Reset View</button>
                <button class="btn btn-secondary" onclick="flipImages()">🔄 Flip Images</button>
                <button class="btn btn-secondary" onclick="toggleOrientation()">↔️ Vertical Split</button>
                <button class="btn btn-secondary" onclick="downloadComparison()">💾 Download</button>
            </div>
            
            <div class="preset-images">
                <button class="preset-btn" onclick="loadPresetImages('nature')">🌲 Nature Demo</button>
                <button class="preset-btn" onclick="loadPresetImages('architecture')">🏛️ Architecture Demo</button>
                <button class="preset-btn" onclick="loadPresetImages('portrait')">👤 Portrait Demo</button>
            </div>
        </div>
        
        <div class="comparison-container" id="comparisonContainer">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                Loading images...
            </div>
            
            <div class="image-container">
                <img id="imageAfter" class="image" alt="After image">
                <div class="image-before">
                    <img id="imageBefore" class="image" alt="Before image">
                </div>
            </div>
            
            <div class="slider" id="slider"></div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">−</button>
            </div>
            
            <div class="info-panel" id="infoPanel">
                <div><strong>Controls:</strong></div>
                <div>• Move mouse to compare</div>
                <div>• Drag slider for manual control</div>
                <div>• Scroll to zoom</div>
                <div>• Drag to pan when zoomed</div>
                <div>• Double-click to reset</div>
                <div id="imageInfo"></div>
            </div>
        </div>
    </div>

    <script>
        class ImageComparison {
            constructor() {
                this.currentZoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.isDragging = false; // For single-finger image panning
                this.isSliderDragging = false; // For manual slider movement
                this.isPinching = false; // For two-finger pinch-to-zoom
        
                this.sliderPosition = 50;
                this.isVertical = false;
                this.isFullscreen = false;
                this.autoFollow = true; // Auto-follow mouse cursor (desktop only)
                this.isTouchDevice = this.detectTouchDevice();
        
                this.requestedAutoFollowFrame = null; // For requestAnimationFrame for auto-follow
                this.requestedSliderDragFrame = null; // For requestAnimationFrame for slider drag
        
                // Properties for 'tap to move slider' and pinch-zoom functionality
                this.lastTouchStartX = 0;
                this.lastTouchStartY = 0;
                this.touchMoveThreshold = 10; // Pixels: if touch moves more than this, it's a drag, not a tap
        
                this.initialPinchDistance = 0; // Distance between two fingers at pinch start
                this.initialPinchZoom = 1;     // Zoom level at pinch start
        
                // Initialize DOM elements
                this.initializeElements();
                // Bind all event listeners
                this.bindEvents();
                // Load initial demo images
                this.loadPresetImages('nature');
            }
        
            /**
             * Initializes references to all necessary DOM elements.
             */
            initializeElements() {
                this.container = document.getElementById('comparisonContainer');
                this.slider = document.getElementById('slider');
                this.imageBefore = document.getElementById('imageBefore');
                this.imageAfter = document.getElementById('imageAfter');
                this.imageBeforeContainer = document.querySelector('.image-before');
                this.infoPanel = document.getElementById('infoPanel');
                this.loading = document.getElementById('loading');
            }
        
            /**
             * Binds all event listeners for file inputs, drag & drop, slider,
             * panning, zooming, and keyboard shortcuts.
             */
            bindEvents() {
                // Event listeners for file input changes
                document.getElementById('image1').addEventListener('change', (e) => this.loadImage(e, 'before'));
                document.getElementById('image2').addEventListener('change', (e) => this.loadImage(e, 'after'));
        
                // Setup drag and drop functionality for file inputs
                this.setupDragAndDrop();
        
                // Container mouse move for auto-follow (desktop only)
                if (!this.isTouchDevice) {
                    this.container.addEventListener('mousemove', (e) => {
                        // Only auto-follow if not manually dragging the slider or panning the image
                        if (this.autoFollow && !this.isSliderDragging && !this.isDragging) {
                            // Use requestAnimationFrame to optimize mousemove handling
                            if (this.requestedAutoFollowFrame) {
                                cancelAnimationFrame(this.requestedAutoFollowFrame);
                            }
                            this.requestedAutoFollowFrame = requestAnimationFrame(() => this.handleMouseMove(e));
                        }
                    });
                    // Re-enable auto-follow when mouse enters the container
                    this.container.addEventListener('mouseenter', () => {
                        this.autoFollow = true;
                    });
                    // Disable auto-follow when mouse leaves the container
                    this.container.addEventListener('mouseleave', () => {
                        this.autoFollow = false;
                        if (this.requestedAutoFollowFrame) {
                            cancelAnimationFrame(this.requestedAutoFollowFrame);
                            this.requestedAutoFollowFrame = null;
                        }
                    });
                }
        
                // Slider events for manual control (Mouse)
                this.slider.addEventListener('mousedown', this.startSliderDrag.bind(this));
                document.addEventListener('mousemove', this.handleDocumentMouseMove.bind(this));
                document.addEventListener('mouseup', this.stopSliderDrag.bind(this));
        
                // Slider events for manual control (Touch)
                this.slider.addEventListener('touchstart', this.startSliderDrag.bind(this));
                document.addEventListener('touchmove', this.handleDocumentTouchMove.bind(this));
                document.addEventListener('touchend', this.stopSliderDrag.bind(this));
                this.slider.addEventListener('touchcancel', this.stopSliderDrag.bind(this)); // Handle interrupted touches
        
                // Pan and zoom events (Mouse)
                this.container.addEventListener('wheel', this.handleWheel.bind(this)); // Mouse wheel for zoom
                this.container.addEventListener('mousedown', this.startPan.bind(this)); // Start panning
                this.container.addEventListener('mousemove', this.handlePan.bind(this)); // Handle panning movement
                document.addEventListener('mouseup', this.stopPan.bind(this)); // Stop panning (on document to catch outside container)
        
                // Pan and zoom events (Touch)
                this.container.addEventListener('touchstart', this.startPanTouch.bind(this));
                this.container.addEventListener('touchmove', this.handlePanTouch.bind(this));
                document.addEventListener('touchend', this.stopPanTouch.bind(this)); // Stop panning (on document to catch outside container)
                document.addEventListener('touchcancel', this.stopPanTouch.bind(this)); // Handle interrupted touches
        
                // Double-click to reset zoom (Mouse & Touch)
                this.container.addEventListener('dblclick', this.resetZoom.bind(this));
        
                // Keyboard shortcuts for various actions
                document.addEventListener('keydown', this.handleKeyboard.bind(this));
            }
        
            /**
             * Sets up drag and drop functionality for the file input labels.
             */
            setupDragAndDrop() {
                const dropZones = document.querySelectorAll('.file-input-label');
        
                dropZones.forEach((zone, index) => {
                    // Prevent default drag behaviors and highlight drop zone
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        zone.style.borderColor = '#00f2fe';
                        zone.style.background = 'rgba(0, 242, 254, 0.2)';
                    });
        
                    // Reset highlight when drag leaves
                    zone.addEventListener('dragleave', () => {
                        zone.style.borderColor = '#4facfe';
                        zone.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%)';
                    });
        
                    // Handle dropped files
                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            const imageType = index === 0 ? 'before' : 'after'; // Determine if it's image 1 or 2
                            this.loadImageFromFile(files[0], imageType);
                        }
                        // Reset highlight after drop
                        zone.style.borderColor = '#4facfe';
                        zone.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%)';
                    });
                });
            }
        
            /**
             * Loads an image from a file input event.
             * @param {Event} event - The change event from the file input.
             * @param {string} type - 'before' or 'after' to determine which image to load.
             */
            loadImage(event, type) {
                const file = event.target.files[0];
                if (file) {
                    this.loadImageFromFile(file, type);
                }
            }
        
            /**
             * Loads an image from a File object.
             * @param {File} file - The File object to load.
             * @param {string} type - 'before' or 'after' to determine which image to load.
             */
            loadImageFromFile(file, type) {
                this.showLoading(); // Show loading indicator
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = type === 'before' ? this.imageBefore : this.imageAfter;
                    img.onload = () => {
                        this.updateImageInfo(); // Update info panel after image loads
                        this.hideLoading(); // Hide loading indicator
                    };
                    img.onerror = () => {
                        this.hideLoading();
                        const infoDiv = document.getElementById('imageInfo');
                        infoDiv.innerHTML = `<div style="color: red; margin-top: 10px;">Error loading image from file: ${file.name}.</div>`;
                        console.error(`Error loading image from file: ${file.name}`);
                    };
                    img.src = e.target.result; // Set image source to data URL
                };
                reader.readAsDataURL(file); // Read file as Data URL
            }
        
            /**
             * Loads an image from a given URL.
             * @param {string} url - The URL of the image to load.
             * @param {string} type - 'before' or 'after' to determine which image to load.
             */
            loadImageFromUrl(url, type) {
                if (!url) {
                    // Use a custom message box instead of alert() in production
                    const infoDiv = document.getElementById('imageInfo');
                    infoDiv.innerHTML = '<div style="color: red; margin-top: 10px;">Please enter a valid image URL.</div>';
                    return;
                }
                this.showLoading(); // Show loading indicator
                const img = type === 'before' ? this.imageBefore : this.imageAfter;
                img.onload = () => {
                    this.updateImageInfo(); // Update info panel after image loads
                    this.hideLoading(); // Hide loading indicator
                };
                img.onerror = () => {
                    // Use a custom message box instead of alert()
                    const infoDiv = document.getElementById('imageInfo');
                    infoDiv.innerHTML = `<div style="color: red; margin-top: 10px;">Failed to load image from URL: ${url}. Please check the URL and ensure it's a valid image and accessible (CORS issues might prevent loading from some domains).</div>`;
                    this.hideLoading(); // Hide loading indicator
                    img.src = ''; // Clear the image source on error to prevent broken image icon
                };
                img.src = url; // Set image source to the provided URL
            }
        
            /**
             * Loads pre-defined demo images based on a type.
             * @param {string} type - The type of preset images ('nature', 'architecture', 'portrait').
             */
            loadPresetImages(type) {
                this.showLoading(); // Show loading indicator
        
                // SVG data URLs for demo images
                const presets = {
                    nature: {
                        before: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <linearGradient id="sky" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#87CEEB"/>
                                        <stop offset="100%" style="stop-color:#98FB98"/>
                                    </linearGradient>
                                </defs>
                                <rect width="800" height="600" fill="url(#sky)"/>
                                <polygon points="100,400 200,200 300,300 400,150 500,250 600,180 700,220 800,200 800,600 0,600" fill="#228B22"/>
                                <circle cx="150" cy="120" r="50" fill="#FFD700"/>
                                <text x="400" y="500" text-anchor="middle" font-family="Arial" font-size="24" fill="#2F4F4F">Original Landscape</text>
                            </svg>
                        `),
                        after: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <linearGradient id="sky2" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#FF7F50"/>
                                        <stop offset="100%" style="stop-color:#FFB347"/>
                                    </linearGradient>
                                </defs>
                                <rect width="800" height="600" fill="url(#sky2)"/>
                                <polygon points="100,400 200,200 300,300 400,150 500,250 600,180 700,220 800,200 800,600 0,600" fill="#8B4513"/>
                                <circle cx="150" cy="120" r="50" fill="#FF4500"/>
                                <text x="400" y="500" text-anchor="middle" font-family="Arial" font-size="24" fill="#8B0000">Enhanced Landscape</text>
                            </svg>
                        `)
                    },
                    architecture: {
                        before: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                                <rect width="800" height="600" fill="#E0E0E0"/>
                                <rect x="200" y="200" width="400" height="300" fill="#C0C0C0" stroke="#808080" stroke-width="2"/>
                                <rect x="250" y="250" width="80" height="80" fill="#696969"/>
                                <rect x="470" y="250" width="80" height="80" fill="#696969"/>
                                <rect x="350" y="400" width="100" height="100" fill="#8B4513"/>
                                <polygon points="180,200 400,100 620,200" fill="#B22222"/>
                                <text x="400" y="550" text-anchor="middle" font-family="Arial" font-size="20" fill="#000">Classic Building</text>
                            </svg>
                        `),
                        after: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <linearGradient id="modern" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#4169E1"/>
                                        <stop offset="100%" style="stop-color:#1E90FF"/>
                                    </linearGradient>
                                </defs>
                                <rect width="800" height="600" fill="#F0F8FF"/>
                                <rect x="200" y="200" width="400" height="300" fill="url(#modern)" stroke="#0000CD" stroke-width="3"/>
                                <rect x="250" y="250" width="80" height="80" fill="#00BFFF"/>
                                <rect x="470" y="250" width="80" height="80" fill="#00BFFF"/>
                                <rect x="350" y="400" width="100" height="100" fill="#4682B4"/>
                                <polygon points="180,200 400,100 620,200" fill="#DC143C"/>
                                <text x="400" y="550" text-anchor="middle" font-family="Arial" font-size="20" fill="#000080">Modern Building</text>
                            </svg>
                        `)
                    },
                    portrait: {
                        before: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="600" height="800" xmlns="http://www.w3.org/2000/svg">
                                <rect width="600" height="800" fill="#F5F5DC"/>
                                <circle cx="300" cy="250" r="100" fill="#FDBCB4"/>
                                <circle cx="270" cy="230" r="8" fill="#000"/>
                                <circle cx="330" cy="230" r="8" fill="#000"/>
                                <path d="M280,270 Q300,285 320,270" stroke="#000" stroke-width="2" fill="none"/>
                                <rect x="250" y="350" width="100" height="150" fill="#4682B4"/>
                                <text x="300" y="600" text-anchor="middle" font-family="Arial" font-size="18" fill="#000">Original Portrait</text>
                            </svg>
                        `),
                        after: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="600" height="800" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <radialGradient id="glow" cx="50%" cy="50%" r="50%">
                                        <stop offset="0%" style="stop-color:#FFE4E1"/>
                                        <stop offset="100%" style="stop-color:#FFF8DC"/>
                                    </radialGradient>
                                </defs>
                                <rect width="600" height="800" fill="url(#glow)"/>
                                <circle cx="300" cy="250" r="100" fill="#FFDBAC"/>
                                <circle cx="270" cy="230" r="8" fill="#000"/>
                                <circle cx="330" cy="230" r="8" fill="#000"/>
                                <path d="M280,270 Q300,285 320,270" stroke="#DC143C" stroke-width="2" fill="none"/>
                                <rect x="250" y="350" width="100" height="150" fill="#8A2BE2"/>
                                <text x="300" y="600" text-anchor="middle" font-family="Arial" font-size="18" fill="#4B0082">Enhanced Portrait</text>
                            </svg>
                        `)
                    }
                };
        
                const preset = presets[type];
                // Ensure both images load before hiding loading indicator
                let imagesLoaded = 0;
                const onImageLoad = () => {
                    imagesLoaded++;
                    if (imagesLoaded === 2) {
                        this.updateImageInfo();
                        this.hideLoading();
                    }
                };
        
                this.imageBefore.onload = onImageLoad;
                this.imageAfter.onload = onImageLoad;
                this.imageBefore.onerror = () => { console.error('Error loading preset before image.'); onImageLoad(); };
                this.imageAfter.onerror = () => { console.error('Error loading preset after image.'); onImageLoad(); };
        
                this.imageBefore.src = preset.before;
                this.imageAfter.src = preset.after;
            }
        
            /**
             * Detects if the device is a touchscreen device.
             * @returns {boolean} True if it's a touch device, false otherwise.
             */
            detectTouchDevice() {
                return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
            }
        
            /**
             * Handles mouse movement over the container for auto-following the slider.
             * @param {MouseEvent} e - The mouse event.
             */
            handleMouseMove(e) {
                // Check if mouse is over slider or its handle area
                const sliderRect = this.slider.getBoundingClientRect();
                const tolerance = 5; // pixels tolerance around slider
        
                let isOverSlider = false;
                if (this.isVertical) {
                    isOverSlider = Math.abs(e.clientY - (sliderRect.top + sliderRect.height / 2)) < tolerance;
                } else {
                    isOverSlider = Math.abs(e.clientX - (sliderRect.left + sliderRect.width / 2)) < tolerance;
                }
        
                // Don't auto-follow if mouse is near slider or if a drag is active
                if (isOverSlider || this.isDragging || this.isSliderDragging || this.isPinching) return;
        
                const rect = this.container.getBoundingClientRect();
        
                if (this.isVertical) {
                    const percentage = ((e.clientY - rect.top) / rect.height) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                } else {
                    const percentage = ((e.clientX - rect.left) / rect.width) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                }
                this.updateSliderPosition(); // Call this to apply changes
                this.requestedAutoFollowFrame = null; // Reset the frame request
            }
        
            /**
             * Initiates slider dragging on mouse down or touch start.
             * @param {Event} e - The mouse or touch event.
             */
            startSliderDrag(e) {
                this.isSliderDragging = true;
                this.autoFollow = false; // Disable auto-follow when manually dragging
                e.preventDefault(); // Prevent default browser actions (e.g., image drag)
            }
        
            /**
             * Handles mouse movement for slider dragging.
             * @param {MouseEvent} e - The mouse event.
             */
            handleDocumentMouseMove(e) {
                if (this.isSliderDragging) {
                    // Use requestAnimationFrame to optimize slider dragging
                    if (this.requestedSliderDragFrame) {
                        cancelAnimationFrame(this.requestedSliderDragFrame);
                    }
                    this.requestedSliderDragFrame = requestAnimationFrame(() => this.handleSliderDrag(e));
                }
            }
        
            /**
             * Updates slider position based on mouse movement.
             * @param {MouseEvent} e - The mouse event.
             */
            handleSliderDrag(e) {
                const rect = this.container.getBoundingClientRect();
                let clientX = e.clientX;
                let clientY = e.clientY;
        
                if (this.isVertical) {
                    const percentage = ((clientY - rect.top) / rect.height) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                } else {
                    const percentage = ((clientX - rect.left) / rect.width) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                }
                this.updateSliderPosition(); // Apply changes
                this.requestedSliderDragFrame = null; // Reset the frame request
            }
        
            /**
             * Handles touch movement for slider dragging.
             * @param {TouchEvent} e - The touch event.
             */
            handleDocumentTouchMove(e) {
                if (this.isSliderDragging) {
                    e.preventDefault(); // Prevent default touch behavior (like scrolling)
                    if (this.requestedSliderDragFrame) {
                        cancelAnimationFrame(this.requestedSliderDragFrame);
                    }
                    this.requestedSliderDragFrame = requestAnimationFrame(() => this.handleSliderDragTouch(e));
                }
            }
        
            /**
             * Updates slider position based on touch movement.
             * @param {TouchEvent} e - The touch event.
             */
            handleSliderDragTouch(e) {
                const touch = e.touches[0]; // Get the first touch point
                const rect = this.container.getBoundingClientRect();
        
                if (this.isVertical) {
                    const percentage = ((touch.clientY - rect.top) / rect.height) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                } else {
                    const percentage = ((touch.clientX - rect.left) / rect.width) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                }
                this.updateSliderPosition(); // Apply changes
                this.requestedSliderDragFrame = null; // Reset the frame request
            }
        
            /**
             * Stops slider dragging on mouse up or touch end.
             */
            stopSliderDrag() {
                this.isSliderDragging = false;
                // Cancel any pending animation frames
                if (this.requestedSliderDragFrame) {
                    cancelAnimationFrame(this.requestedSliderDragFrame);
                    this.requestedSliderDragFrame = null;
                }
                if (this.requestedAutoFollowFrame) {
                    cancelAnimationFrame(this.requestedAutoFollowFrame);
                    this.requestedAutoFollowFrame = null;
                }
        
                // Re-enable auto-follow after manual drag ends (for desktop only)
                if (!this.isTouchDevice) {
                    setTimeout(() => {
                        this.autoFollow = true;
                    }, 100); // Small delay to prevent immediate re-triggering
                }
            }
        
            /**
             * Handles mouse wheel events for zooming.
             * @param {WheelEvent} e - The wheel event.
             */
            handleWheel(e) {
                e.preventDefault(); // Prevent page scrolling
        
                const delta = e.deltaY > 0 ? 0.9 : 1.1; // Determine zoom direction
                const newZoom = this.currentZoom * delta;
        
                // Limit zoom level
                if (newZoom >= 0.1 && newZoom <= 50) {
                    this.currentZoom = newZoom;
                    this.updateTransform(); // Apply new zoom
                }
            }
        
            /**
             * Initiates panning on mouse down.
             * @param {MouseEvent} e - The mouse event.
             */
            startPan(e) {
                // Don't start panning if clicking on slider or zoom controls
                if (e.target === this.slider ||
                    e.target.closest('.zoom-controls') ||
                    e.target.closest('.slider') ||
                    this.isSliderDragging) return;
        
                this.isDragging = true;
                this.lastX = e.clientX; // Store initial mouse X
                this.lastY = e.clientY; // Store initial mouse Y
                this.container.style.cursor = 'grabbing'; // Change cursor for visual feedback
        
                this.autoFollow = false; // Disable auto-follow while panning
            }
        
            /**
             * Handles panning movement on mouse move.
             * @param {MouseEvent} e - The mouse event.
             */
            handlePan(e) {
                if (!this.isDragging || this.isSliderDragging) return; // Only pan if dragging is active and slider is not dragging
        
                const deltaX = e.clientX - this.lastX; // Calculate change in X
                const deltaY = e.clientY - this.lastY; // Calculate change in Y
        
                this.panX += deltaX; // Update pan offset X
                this.panY += deltaY; // Update pan offset Y
        
                this.lastX = e.clientX; // Update last X for next movement
                this.lastY = e.clientY; // Update last Y for next movement
        
                this.updateTransform(); // Apply new pan offsets
        
                this.autoFollow = false; // Keep auto-follow disabled while panning
            }
        
            /**
             * Stops panning on mouse up.
             */
            stopPan() {
                this.isDragging = false;
                this.container.style.cursor = 'grab'; // Reset cursor
        
                // Re-enable auto-follow after panning ends (for desktop only)
                if (!this.isTouchDevice) {
                    setTimeout(() => {
                        this.autoFollow = true;
                    }, 100);
                }
            }
        
            /**
             * Initiates touch interaction (pan or pinch-zoom).
             * @param {TouchEvent} e - The touch event.
             */
            startPanTouch(e) {
                // IMPORTANT: Allow the exit fullscreen button to be touched
                if (e.target.closest('.exit-fullscreen')) {
                    return; // Let the button handle its own touch events
                }
        
                if (e.touches.length === 1) {
                    e.preventDefault(); // Prevent default browser scrolling/zooming for single touch
                    this.isDragging = false; // Assume not dragging yet, will set in handlePanTouch
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    this.lastTouchStartX = e.touches[0].clientX; // For tap detection
                    this.lastTouchStartY = e.touches[0].clientY; // For tap detection
                    this.autoFollow = false;
                } else if (e.touches.length === 2) {
                    this.startPinchZoom(e); // Start pinch-zoom if two fingers
                }
            }
        
            /**
             * Handles touch movement (pan or pinch-zoom).
             * @param {TouchEvent} e - The touch event.
             */
            handlePanTouch(e) {
                if (e.touches.length === 1) {
                    if (this.isPinching || this.isSliderDragging) return; // If already pinching or slider dragging, ignore single touch move
        
                    e.preventDefault(); // Prevent default browser scrolling/zooming
        
                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
        
                    const deltaX = currentX - this.lastX;
                    const deltaY = currentY - this.lastY;
        
                    // If movement exceeds threshold, it's a drag/pan
                    if (!this.isDragging && (Math.abs(deltaX) > this.touchMoveThreshold || Math.abs(deltaY) > this.touchMoveThreshold)) {
                        this.isDragging = true;
                        this.container.style.cursor = 'grabbing';
                    }
        
                    if (this.isDragging) {
                        this.panX += deltaX;
                        this.panY += deltaY;
                        this.updateTransform();
                    }
        
                    this.lastX = currentX;
                    this.lastY = currentY;
                } else if (e.touches.length === 2) {
                    this.handlePinchZoom(e); // Handle pinch-zoom if two fingers
                }
            }
        
            /**
             * Stops touch interaction (pan or pinch-zoom).
             * @param {TouchEvent} e - The touch event.
             */
            stopPanTouch(e) {
                // Check if it was a tap (not a drag, not a slider drag, and not a pinch)
                if (!this.isDragging && !this.isSliderDragging && !this.isPinching && e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const deltaX = Math.abs(touch.clientX - this.lastTouchStartX);
                    const deltaY = Math.abs(touch.clientY - this.lastTouchStartY);
        
                    if (deltaX <= this.touchMoveThreshold && deltaY <= this.touchMoveThreshold) {
                        this.handleContainerTap(e); // Call the dedicated tap handler
                    }
                }
        
                this.isDragging = false;
                this.isPinching = false; // Reset pinching state
                this.initialPinchDistance = 0; // Reset pinch state
                this.container.style.cursor = 'grab';
        
                if (!this.isTouchDevice) {
                    setTimeout(() => {
                        this.autoFollow = true;
                    }, 100);
                }
            }
        
            /**
             * Calculates the distance between two touch points.
             * @param {TouchList} touches - The TouchList object.
             * @returns {number} The distance between the two touches.
             */
            getDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
        
            /**
             * Initiates pinch-to-zoom.
             * @param {TouchEvent} e - The touch event.
             */
            startPinchZoom(e) {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent default browser zoom/scroll
                    this.isPinching = true;
                    this.initialPinchDistance = this.getDistance(e.touches);
                    this.initialPinchZoom = this.currentZoom;
                    this.autoFollow = false; // Disable auto-follow during pinch
                }
            }
        
            /**
             * Handles pinch-to-zoom movement.
             * @param {TouchEvent} e - The touch event.
             */
            handlePinchZoom(e) {
                if (e.touches.length === 2 && this.isPinching) {
                    e.preventDefault(); // Prevent default browser zoom/scroll
        
                    const currentPinchDistance = this.getDistance(e.touches);
                    if (this.initialPinchDistance === 0) return; // Avoid division by zero
        
                    const zoomFactor = currentPinchDistance / this.initialPinchDistance;
                    let newZoom = this.initialPinchZoom * zoomFactor;
        
                    // Clamp zoom to limits
                    newZoom = Math.max(0.1, Math.min(50, newZoom));
        
                    // Calculate pan offset to zoom around the center of the pinch
                    const rect = this.container.getBoundingClientRect();
                    const touchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const touchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        
                    // Calculate the point in the *original* image coordinates that the pinch is centered on
                    // This is the point relative to the image's current top-left corner, scaled by the current zoom
                    const originalPointX = (touchCenterX - rect.left - this.panX) / this.currentZoom;
                    const originalPointY = (touchCenterY - rect.top - this.panY) / this.currentZoom;
        
                    // Calculate new pan based on the new zoom and the fixed original point
                    this.panX = touchCenterX - rect.left - (originalPointX * newZoom);
                    this.panY = touchCenterY - rect.top - (originalPointY * newZoom);
        
                    this.currentZoom = newZoom;
                    this.updateTransform();
                }
            }
        
            /**
             * Handles tap events on the comparison container to move the slider.
             * This is triggered on `touchend` if it wasn't a drag or pinch.
             * @param {TouchEvent} e - The touch event.
             */
            handleContainerTap(e) {
                const touch = e.changedTouches[0]; // Use changedTouches as this is from touchend
                const rect = this.container.getBoundingClientRect();
        
                if (this.isVertical) {
                    const percentage = ((touch.clientY - rect.top) / rect.height) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                } else {
                    const percentage = ((touch.clientX - rect.left) / rect.width) * 100;
                    this.sliderPosition = Math.max(0, Math.min(100, percentage));
                }
                this.updateSliderPosition(); // Apply the new slider position
            }
        
            /**
             * Applies the current zoom and pan transformations to the images.
             */
            updateTransform() {
                const transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.currentZoom})`;
                this.imageBefore.style.transform = transform;
                this.imageAfter.style.transform = transform;
                this.updateImageInfo(); // Update info panel with new zoom/pan
            }
        
            /**
             * Resets zoom and pan to default values.
             */
            resetZoom() {
                this.currentZoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.updateTransform(); // Apply reset transformations
            }
        
            /**
             * Increases the zoom level.
             */
            zoomIn() {
                if (this.currentZoom < 10) { // Max zoom limit
                    this.currentZoom *= 1.2; // Increase zoom by 20%
                    this.updateTransform();
                }
            }
        
            /**
             * Decreases the zoom level.
             */
            zoomOut() {
                if (this.currentZoom > 0.1) { // Min zoom limit
                    this.currentZoom /= 1.2; // Decrease zoom by 20%
                    this.updateTransform();
                }
            }
        
            /**
             * Toggles fullscreen mode for the comparison container.
             */
            toggleFullscreen() {
                if (!this.isFullscreen) {
                    this.enterFullscreen();
                } else {
                    this.exitFullscreen();
                }
            }
        
            /**
             * Enters fullscreen mode for the comparison container.
             */
            enterFullscreen() {
                this.isFullscreen = true;
                document.body.style.overflow = 'hidden'; // Prevent body scrolling
                this.container.classList.add('fullscreen'); // Add fullscreen class for styling
        
                // Add an exit fullscreen button
                const exitBtn = document.createElement('button');
                exitBtn.className = 'exit-fullscreen';
                exitBtn.innerHTML = '✕';
                exitBtn.onclick = () => this.exitFullscreen();
                this.container.appendChild(exitBtn);
        
                // Request actual browser fullscreen if supported
                if (this.container.requestFullscreen) {
                    this.container.requestFullscreen();
                } else if (this.container.webkitRequestFullscreen) { // Safari
                    this.container.webkitRequestFullscreen();
                }
            }
        
            /**
             * Exits fullscreen mode.
             */
            exitFullscreen() {
                this.isFullscreen = false;
                document.body.style.overflow = 'auto'; // Re-enable body scrolling
                this.container.classList.remove('fullscreen'); // Remove fullscreen styling
        
                // Remove the exit fullscreen button
                const exitBtn = this.container.querySelector('.exit-fullscreen');
                if (exitBtn) {
                    exitBtn.remove();
                }
        
                // Exit actual browser fullscreen if supported
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { // Safari
                    document.webkitExitFullscreen();
                }
            }
        
            /**
             * Swaps the 'before' and 'after' images.
             */
            flipImages() {
                const beforeSrc = this.imageBefore.src;
                const afterSrc = this.imageAfter.src;
        
                this.imageBefore.src = afterSrc;
                this.imageAfter.src = beforeSrc;
        
                this.updateImageInfo(); // Update info panel
            }
        
            /**
             * Toggles the orientation of the image split (horizontal/vertical).
             */
            toggleOrientation() {
                this.isVertical = !this.isVertical;
        
                // Reset slider position to 50% for new orientation to avoid odd behavior
                this.sliderPosition = 50;
                this.updateSliderPosition(); // Apply new orientation and position
        
                // Adjust slider and image-before-container styles based on orientation
                if (this.isVertical) {
                    this.slider.style.width = '100%';
                    this.slider.style.height = '1px';
                    this.slider.style.cursor = 'ns-resize'; // North-south resize cursor
                    this.slider.style.transform = 'translateY(-50%)'; // Vertically center slider line
                    this.slider.style.left = '0'; // Ensure it spans full width
                } else {
                    this.slider.style.width = '1px';
                    this.slider.style.height = '100%';
                    this.slider.style.cursor = 'ew-resize'; // East-west resize cursor
                    this.slider.style.transform = 'translateX(-50%)'; // Horizontally center slider line
                    this.slider.style.top = '0'; // Ensure it spans full height
                }
            }
        
            /**
             * Downloads the current comparison view as a PNG image.
             * Note: This might have CORS issues with images loaded from external URLs
             * unless the server explicitly allows cross-origin image loading.
             */
            downloadComparison() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
        
                const img1 = new Image();
                const img2 = new Image();
        
                // Set crossOrigin to 'anonymous' to try and enable CORS for images,
                // but this only works if the server hosting the image supports it.
                img1.crossOrigin = 'anonymous';
                img2.crossOrigin = 'anonymous';
        
                let loadedCount = 0;
                const checkAndDraw = () => {
                    loadedCount++;
                    if (loadedCount === 2) {
                        canvas.width = Math.max(img1.width, img2.width);
                        canvas.height = Math.max(img1.height, img2.height);
        
                        // Draw the 'after' image first (full background)
                        ctx.drawImage(img2, 0, 0, canvas.width, canvas.height);
        
                        // Draw the 'before' image, clipped by the current slider position
                        if (this.isVertical) {
                            const splitY = (canvas.height * this.sliderPosition) / 100;
                            ctx.drawImage(img1, 0, 0, canvas.width, splitY, 0, 0, canvas.width, splitY);
                        } else {
                            const splitX = (canvas.width * this.sliderPosition) / 100;
                            ctx.drawImage(img1, 0, 0, splitX, canvas.height, 0, 0, splitX, canvas.height);
                        }
        
                        // Add slider line for visual clarity in the downloaded image
                        ctx.strokeStyle = '#4facfe'; // Matching theme color
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        if (this.isVertical) {
                            const y = (canvas.height * this.sliderPosition) / 100;
                            ctx.moveTo(0, y);
                            ctx.lineTo(canvas.width, y);
                        } else {
                            const x = (canvas.width * this.sliderPosition) / 100;
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, canvas.height);
                        }
                        ctx.stroke();
        
                        // Trigger download
                        const link = document.createElement('a');
                        link.download = 'image-comparison.png';
                        link.href = canvas.toDataURL('image/png'); // Get image data as PNG
                        link.click();
                    }
                };
        
                img1.onload = checkAndDraw;
                img2.onload = checkAndDraw;
        
                img1.onerror = () => {
                    console.error('Error loading before image for download. Check CORS.');
                    checkAndDraw(); // Still try to proceed if one image fails
                };
                img2.onerror = () => {
                    console.error('Error loading after image for download. Check CORS.');
                    checkAndDraw(); // Still try to proceed if one image fails
                };
        
                img1.src = this.imageBefore.src;
                img2.src = this.imageAfter.src;
            }
        
            /**
             * Updates the information panel with current zoom, slider position, and mode.
             */
            updateImageInfo() {
                const info = document.getElementById('imageInfo');
                info.innerHTML = `
                    <div style="margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
                        <div>Zoom: ${Math.round(this.currentZoom * 100)}%</div>
                        <div>Slider: ${Math.round(this.sliderPosition)}%</div>
                        <div>Mode: ${this.isVertical ? 'Vertical' : 'Horizontal'}</div>
                    </div>
                `;
            }
        
            /**
             * Displays the loading indicator.
             */
            showLoading() {
                this.loading.style.display = 'block';
            }
        
            /**
             * Hides the loading indicator.
             */
            hideLoading() {
                this.loading.style.display = 'none';
            }
        
            /**
             * Handles keyboard shortcuts for various actions.
             * @param {KeyboardEvent} e - The keyboard event.
             */
            handleKeyboard(e) {
                // Do not interfere with typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
                switch(e.key) {
                    case 'f':
                    case 'F':
                        this.toggleFullscreen();
                        break;
                    case 'r':
                    case 'R':
                        this.resetZoom();
                        break;
                    case 'v':
                    case 'V':
                        this.toggleOrientation();
                        break;
                    case 'ArrowLeft':
                        if (!this.isVertical && this.sliderPosition > 0) { // Only for horizontal slider
                            this.sliderPosition -= 1;
                            this.updateSliderPosition();
                            e.preventDefault(); // Prevent page scrolling
                        }
                        break;
                    case 'ArrowRight':
                        if (!this.isVertical && this.sliderPosition < 100) { // Only for horizontal slider
                            this.sliderPosition += 1;
                            this.updateSliderPosition();
                            e.preventDefault(); // Prevent page scrolling
                        }
                        break;
                    case 'ArrowUp':
                        if (this.isVertical && this.sliderPosition > 0) { // Only for vertical slider
                            this.sliderPosition -= 1;
                            this.updateSliderPosition();
                            e.preventDefault(); // Prevent page scrolling
                        } else if (!this.isVertical) { // For pan up in horizontal mode
                            this.panY -= 10;
                            this.updateTransform();
                            e.preventDefault(); // Prevent page scrolling
                        }
                        break;
                    case 'ArrowDown':
                        if (this.isVertical && this.sliderPosition < 100) { // Only for vertical slider
                            this.sliderPosition += 1;
                            this.updateSliderPosition();
                            e.preventDefault(); // Prevent page scrolling
                        } else if (!this.isVertical) { // For pan down in horizontal mode
                            this.panY += 10;
                            this.updateTransform();
                            e.preventDefault(); // Prevent page scrolling
                        }
                        break;
                    case 'Escape':
                        if (this.isFullscreen) {
                            this.exitFullscreen();
                        }
                        break;
                    case '+':
                        this.zoomIn();
                        break;
                    case '-':
                        this.zoomOut();
                        break;
                }
            }
        
            /**
             * Updates the visual position of the slider and the clip-path of the 'before' image.
             */
            updateSliderPosition() {
                if (this.isVertical) {
                    this.slider.style.top = this.sliderPosition + '%';
                    this.slider.style.left = '0'; // Ensure it's aligned to the left edge
                    this.imageBeforeContainer.style.clipPath = `polygon(0 0, 100% 0, 100% ${this.sliderPosition}%, 0 ${this.sliderPosition}%)`;
                } else {
                    this.slider.style.left = this.sliderPosition + '%';
                    this.slider.style.top = '0'; // Ensure it's aligned to the top edge
                    this.imageBeforeContainer.style.clipPath = `polygon(0 0, ${this.sliderPosition}% 0, ${this.sliderPosition}% 100%, 0 100%)`;
                }
                this.updateImageInfo(); // Update info panel
            }
        }
        
        // Global functions to be called from HTML buttons (delegated to the comparison instance)
        let comparison; // Declare a global variable to hold the ImageComparison instance
        
        function toggleFullscreen() {
            comparison.toggleFullscreen();
        }
        
        function resetZoom() {
            comparison.resetZoom();
        }
        
        function flipImages() {
            comparison.flipImages();
        }
        
        function toggleOrientation() {
            comparison.toggleOrientation();
        }
        
        function downloadComparison() {
            comparison.downloadComparison();
        }
        
        function zoomIn() {
            comparison.zoomIn();
        }
        
        function zoomOut() {
            comparison.zoomOut();
        }
        
        function loadPresetImages(type) {
            comparison.loadPresetImages(type);
        }
        
        // Initialize the app when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            comparison = new ImageComparison();
        });
        
        // Handle fullscreen change events triggered by browser (e.g., F11 key)
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && comparison.isFullscreen) {
                comparison.exitFullscreen(); // Ensure internal state is updated if exited externally
            }
        });
        
        document.addEventListener('webkitfullscreenchange', () => { // For Safari
            if (!document.webkitFullscreenElement && comparison.isFullscreen) {
                comparison.exitFullscreen(); // Ensure internal state is updated if exited externally
            }
        });
    </script>
</body>
</html>